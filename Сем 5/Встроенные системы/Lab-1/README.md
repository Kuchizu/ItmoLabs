# Assignment: ELF64 file loader
---
Лабораторная работа: Загрузка ELF64 файла

# Подготовка

- Прочитайте документацию по формату PE файла: https://www.uclibc.org/docs/elf-64-gen.pdf
- Ознакомьтесь с правилами MISRA C, доступным начиная со страницы 12 в http://easyelectronics.ru/files/Book/misra_c_rus.pdf

# Задание

Необходимо реализовать чтение и загрузку в виртуальную память файла в формате ELF64 и передачу управления на стартовый адрес указанной секции.
Формат использования утилиты следующий:

```C
./elf64-loader <source-elf64-file> <section-name>
```

Аргументы:
  - `<source-elf64-file>` - имя файла в формате ELF64
  - `<section-name>` - имя секции, стартовому адресу которой необходимо передать управление после загрузки ELF64 файла в виртуальную память.

Требования к реализации:
  - Код размещается в директории `solution/src`, заголовочные файлы ищутся в `solution/include`;
  - Код должен быть написан аккуратно, читаемо и разбит на функции (минимум);
  - Ввиду требований к реализации, необходима поддержка GNU-совместимых компиляторов;
  - Грузиться будут только загружамые данные, хранящиеся в файле ELF64;
  - Позиционно-независимый (PIC) код из ELF64 не поддерживается;
  - Динамические библиотеки не поддерживаются;
  - Сообщения об ошибках выводятся только в стандартный поток ошибок (`stderr` равный 2);
  - В стандартный поток вывода утилита не должна выводить ничего (но можно предусмотреть ключ `-v` для диагностики);
  - В случае возникновения ошибки в ходе выполнения прогарммы, ошибку следует обработать, и, если выполнение продолжить невозможно, то надо возвращать не какое-то ненулевое число, а один из стандартных кодов ошибки:
    - Стандартные коды ошибки можно посмотеть в `/usr/include/asm-generic/errno-base.h`;
    - Если входной файл не найден, то надо вернуть `ENOENT` равный 2;
    - При ошибке ввода-вывода надо вернуть `EIO` равный 5;
    - Если утилите переданы некорректные аргументы (их мало или требуемая секция не найдена, или у неё нет прав на выполнение) надо вернуть `EINVAL` равный 22;
    - и т.д.

На реализацию накладываются следующие ограничения (но при желании можно реализовать код, полностью по стандарту MISRA C, но данный минимум необходимо поддержать):
  - Код долнен соответсвовать стандарту C99;
  - Код должен компилироваться без ошибок или замечаний с ключами `-Wpedantic -Wall`;
  - Должны обрабатываться все нештатные ситуации и ошибки в процессе работы утилиты;
  - Запрещено использование стандартной библиотеки ввода-вывода (stdio.h);
  - Запрещено использование стандартного аллокатора памяти (`malloc`, `calloc`, и т.д.);
  - Запрещено использование стандартных функций работы со сторками (string.h);
  - Запрешено использование команд `goto` и `continue`;
  - Команда `break` может быть использована только в рамках `switch`;
  - Запрещено использование платформо-зависимых типов за исключением счеткичов (`int`) и символов (`char`);
  - Не должно быть никаких закоментированных фрагментов кода.

# ELF64 файл

ELF64 файлы используются в ОС Linux для хранения объектных и исполняемых файлов. Все заголовки ELF64 файлов доступны в заголовочном файле `elf.h`.

Формат ELF64 файла достаточно простой. Файл состоит из нескольих заголовков и данных, которые должны быть загружены в соответствующие адреса виртуальной памяти.

## Заголовок файла

Файл ELF64 начинается с заголовка, содержащего основную информацию о файле (все эти структуры и константы определены в заголовочном файле `elf.h`):

```C
typedef struct
{
  unsigned char e_ident[16]; /* ELF identification */
  Elf64_Half e_type;         /* Object file type */
  Elf64_Half e_machine;      /* Machine type */
  Elf64_Word e_version;      /* Object file version */
  Elf64_Addr e_entry;        /* Entry point address */
  Elf64_Off  e_phoff;        /* Program header offset */
  Elf64_Off  e_shoff;        /* Section header offset */
  Elf64_Word e_flags;        /* Processor-specific flags */
  Elf64_Half e_ehsize;       /* ELF header size */
  Elf64_Half e_phentsize;    /* Size of program header entry */
  Elf64_Half e_phnum;        /* Number of program header entries */
  Elf64_Half e_shentsize;    /* Size of section header entry */
  Elf64_Half e_shnum;        /* Number of section header entries */
  Elf64_Half e_shstrndx;     /* Section name string table index */
} Elf64_Ehdr;
```

После чтения заголовка обязательным условием является проверка magic number в поле идентификатора (`e_ident`). Первые четыре байла должны равняться `\x7f`, 
`E`, `L` и `F` соответственно.

В данном заголовке вас больше всего вас будут интересовать следующие поля:
- `e_phoff` - смещение на первый из программных заголовков;
- `e_phnum` - количество программных заголовков;
- `e_shoff` - смещение на первый заголовок секции;
- `e_shnum` - количество заголовков секций;
- `e_shstrndx` - индекс секции с таблицой имен секций.

Так как по заданию нам запрещено использование стандартной библиотеки ввода-вывода, то и использование функций работы с файлами (`fopen`, `fread` и т.д.) нам тоже запрещены. Вместо этого надо использовать системные функции ОС Linux, а именно `open`, `read`, `write`, `lseek` и т.д.

## Программный заголовок (Program header)

Программные заголовки находятся начиная со смещения `e_phoff`, храняшегося в основном заголовке ELF64, и содержат информацию об областях виртуальной памяти и что в них надо загрузить:

```C
typedef struct
{
  Elf64_Word  p_type;   /* Type of segment */
  Elf64_Word  p_flags;  /* Segment attributes */
  Elf64_Off   p_offset; /* Offset in file */
  Elf64_Addr  p_vaddr;  /* Virtual address in memory */
  Elf64_Addr  p_paddr;  /* Reserved */
  Elf64_Xword p_filesz; /* Size of segment in file */
  Elf64_Xword p_memsz;  /* Size of segment in memory */
  Elf64_Xword p_align;  /* Alignment of segment */
} Elf64_Phdr;
```

В данном заголовке вас больше всего вас будут интересовать следующие поля:
- `p_type` - тип сегмента, загружать в виртуальную память будем только сегменты типа `PT_LOAD`;
- `p_flags` - флаги сегмента, надо задать права на доступ к памяти в соответствии со значением флагов (`PT_X`, `PT_R`, `PT_W`);
- `p_vaddr` - стартовый адрес виртуальной памяти, куда должны быть загружены данные;
- `p_memsz` - объем виртуальной памяти, куда должны грузиться данные (он может быть больше, чем записано данных в файле);
- `p_offset` - смещение в файле, откуда надо грузить данные в виртуальную память;
- `p_memsz` - объем данных в памяти.

Для выделения сегмента в виртуальной памяти следует использовать функцию `mmap`, для установки прав на сегмент после загрузки данных пригодится функция `mprotect`. Документация на эти функции доступна в страницах `man`.

На что стоит обратить внимание во время загрузки данных в память:
- Старт диапазона виртуальной памяти может быть не кратен размеру страницы (0x1000 байт) и его необходимо будет выравнивать (флаг выравнивания в данной работе мы игнорируем);
- Размер сегмента виртуальной памяти после выравнивания стартового адреса может измениться и это тоже должно быть учтено (напрмер вместо одного блока по 0x1000 байт может придется выделить два).

## Заголовок секции (Section header)

Заголовки секций начинаются со смещения `e_shoff` из заголовка ELF64 файлв. Они содержат информацию об секциях и привязку секций как к виртуальной памяти, так и к файлу:

```C
typedef struct
{
  Elf64_Word  sh_name;      /* Section name */
  Elf64_Word  sh_type;      /* Section type */
  Elf64_Xword sh_flags;     /* Section attributes */
  Elf64_Addr  sh_addr;      /* Virtual address in memory */
  Elf64_Off   sh_offset;    /* Offset in file */
  Elf64_Xword sh_size;      /* Size of section */
  Elf64_Word  sh_link;      /* Link to other section */
  Elf64_Word  sh_info;      /* Miscellaneous information */
  Elf64_Xword sh_addralign; /* Address alignment boundary */
  Elf64_Xword sh_entsize;   /* Size of entries, if section has table */
} Elf64_Shdr;
```

В данном заголовке вас больше всего вас будут интересовать следующие поля:
- `sh_name` -  имя секции;
- `sh_addr` - адрес в виртуальной памяти, с которой начинается данная секция.

Вот мы наконец и нашли имя секции, которой требуется передать управление. Но, в данном поле хранится не просто имя, а смещение на начало имени (нуль-терминированной строки) относительно начала таблицы имен.

## Таблица имён (Section name string table)

Таблица имен находится по смещению секции под индексом `e_shstrndx` из основного заголовка файлов. Таблица имен содержит нуль-терминированые строки с именами.

## Система сборки и тестирования

Для сборки кода вам предоставлена система сборки на языке CMake, самим писать систему сборки не требуется.

- В зависимости от платформы и компилятора, система сборки поддерживает несколько конфигураций с динамическими
  анализаторами (санитайзерами). Санитайзеры могут дать подробную информацию о возможных и реальных ошибках в
  программе вместо классического сообщения о segmentation fault. Выбрать подходящую конфигурацию вы можете с
  помощью переменной `CMAKE_BUILD_TYPE`:
  - `ASan` &mdash; [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html),
    набор проверок на некорректное использование адресов памяти. Примеры:
    use-after-free, double-free, выход за пределы стека, кучи или статического блока.
  - `LSan` &mdash; [LeakSanitizer](https://clang.llvm.org/docs/LeakSanitizer.html),
    проверки на утечки памяти.
  - `MSan` &mdash; [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html),
    проверяет, что любая используемая ячейка памяти проинициализирована на момент чтения из нее.
  - `UBSan` &mdash; [UndefinedBehaviourSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html),
    набор базовых проверок на неопределенное поведение. Примеры: переполнение численного типа,
    null-pointer dereference.
- Если в вашей системе имеется статический анализатор `clang-tidy`, он будет запущен во время компиляции программы.
  Список проверок описан в файле `clang-tidy-checks.txt`. Вы можете добавить свои проверки в конец этого файла.
- Директория `tester` содержит код и изображения для тестирования вашей программы. Для запуска тестов используется CTest.
- Поддержана интеграция системы сборки со средами разработки CLion, Visual Studio и Visual Studio Code.

Чтобы система сборки работала на вашей системе, вам необходимо:

### Linux и MacOS

- Компилятор (`gcc`/`clang`) и `cmake` (проверьте, что `cmake` версии 3.12 или выше)
- Если вы хотите использовать санитайзеры с GCC, установите `libasan`, `liblsan` и `libubsan` с помощью пакетного менеджера (названия могут отличаться).
- Если вы хотите использовать санитайзеры с Clang, на некоторых системах вам может понадобиться пакет `compiler-rt`.
- Если вы хотите пользоваться `clang-tidy`, установите `clang-tools-extra`.

### Windows

- Какая-либо среда разработки (CLion, Visual Studio, Visual Studio Code)
- Если вы хотите пользоваться `clang-tidy`, скачайте LLVM: https://github.com/llvm/llvm-project/releases (найдите установщик win64 под одной из версий)
- Для VS Code требуется отдельно поставить Visual Studio (с сайта Microsoft) и CMake: https://cmake.org/download/

### Инструкции по сборке и тестированию

- [Работа с терминалом](docs/Terminal.md)
- [CLion](docs/CLion.md)
- [Visual Studio](docs/VisualStudio.md)
- [Visual Studio Code](docs/VSCode.md)
- [Как обновить свою лабораторную, если преподаватель попросил "подтянуть к себе свежие изменения" из основного репозитория](https://gitlab.se.ifmo.ru/embedded-systems/embedded-systems-fall-2024/assignment-1-elf64-loader/-/blob/master/docs/Terminal.md#%D0%BA%D0%B0%D0%BA-%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D1%8E-%D0%BB%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D1%83%D1%8E-%D0%B5%D1%81%D0%BB%D0%B8-%D0%BF%D1%80%D0%B5%D0%BF%D0%BE%D0%B4%D0%B0%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-%D0%BF%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D0%B8%D0%BB-%D0%BF%D0%BE%D0%B4%D1%82%D1%8F%D0%BD%D1%83%D1%82%D1%8C-%D0%BA-%D1%81%D0%B5%D0%B1%D0%B5-%D1%81%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D0%B7-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F)

