--
-- доп.1 - сделать, чтобы запрос выводил отличников в алфавитном порядке
--

SELECT "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
FROM "Н_ВЕДОМОСТИ"
JOIN "Н_ОЦЕНКИ" ON "Н_ВЕДОМОСТИ"."ОЦЕНКА" = "Н_ОЦЕНКИ"."КОД"
JOIN "Н_УЧЕНИКИ" ON "Н_ВЕДОМОСТИ"."ЧЛВК_ИД" = "Н_УЧЕНИКИ"."ЧЛВК_ИД"
JOIN "Н_ПЛАНЫ" ON "Н_УЧЕНИКИ"."ПЛАН_ИД" = "Н_ПЛАНЫ"."ИД"
JOIN "Н_ОТДЕЛЫ" ON "Н_ПЛАНЫ"."ОТД_ИД" = "Н_ОТДЕЛЫ"."ИД"
JOIN "Н_ЛЮДИ" ON "Н_УЧЕНИКИ"."ЧЛВК_ИД" = "Н_ЛЮДИ"."ИД"
WHERE "Н_ОТДЕЛЫ"."КОРОТКОЕ_ИМЯ" = 'КТиУ' AND "Н_ОЦЕНКИ"."СОРТ" >= 5
GROUP BY "Н_ЛЮДИ"."ИД", "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
ORDER BY "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО";

---------------------------------------------------------------------------------------------

--
-- доп.2
-- 

-- вывести:
-- 1) список студентов МУЖСКОГО ПОЛА и с фамилиями на буквы от К до С
-- 2) которые сдавали сессию за последние 10 лет 
-- 3) в аудиториях на 3 этаже (ограничить трёхзначными)
-- 4) и сдали на хорошо

-- * найду предположительно нужные таблички в инфологической модели
-- 1) Н_ЛЮДИ, Н_УЧЕНИКИ
-- 2) Н_СЕССИЯ
-- 3) Н_СЕССИЯ имеет после Н_АУДИТОРИЯ. первая цифра - это этаж. брать только трёхзначные
-- 4) Н_ВЕДОМОСТИ -> Н_ОЦЕНКИ

SELECT "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
FROM "Н_ВЕДОМОСТИ"
JOIN "Н_ОЦЕНКИ" ON "Н_ВЕДОМОСТИ"."ОЦЕНКА" = "Н_ОЦЕНКИ"."КОД"
JOIN "Н_УЧЕНИКИ" ON "Н_ВЕДОМОСТИ"."ЧЛВК_ИД" = "Н_УЧЕНИКИ"."ЧЛВК_ИД"
JOIN "Н_ЛЮДИ" ON "Н_УЧЕНИКИ"."ЧЛВК_ИД" = "Н_ЛЮДИ"."ИД"
JOIN "Н_СЕССИЯ" ON "Н_ВЕДОМОСТИ"."СЭС_ИД" = "Н_СЕССИЯ"."ИД"
WHERE "Н_ЛЮДИ"."ПОЛ" = 'М' AND
      "Н_ЛЮДИ"."ФАМИЛИЯ" >= 'К' AND "Н_ЛЮДИ"."ФАМИЛИЯ" < 'Т' AND
      "Н_СЕССИЯ"."ДАТА" >= CURRENT_DATE - INTERVAL '10 years' AND
      "Н_СЕССИЯ"."АУДИТОРИЯ" >= '300' AND "Н_СЕССИЯ"."АУДИТОРИЯ" < '400' AND
      "Н_ОЦЕНКИ"."СОРТ" >= 4
GROUP BY "Н_ЛЮДИ"."ИД", "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО"
ORDER BY "Н_ЛЮДИ"."ФАМИЛИЯ", "Н_ЛЮДИ"."ИМЯ", "Н_ЛЮДИ"."ОТЧЕСТВО";

---------------------------------------------------------------------------------------------

--
-- Какие бывают подзапросы? Привести примеры для каждого вида и объяснить различие.
--

-- Подзапросы могут быть разделены на следующие виды:

-- 1) Скалярные подзапросы: Эти подзапросы возвращают только одно значение (одну строку и один столбец). 
-- Они часто используются в операторах сравнения, в операторе SELECT или в выражениях. 
-- Например:

SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 2) Подзапросы в списках: Эти подзапросы возвращают один или несколько столбцов и могут быть использованы с операторами IN, ANY или ALL. 
-- Например:

SELECT name, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE name LIKE '%IT%');

-- 3) Коррелированные подзапросы: Это подзапросы, которые зависят от внешнего запроса и выполняются для каждой строки внешнего запроса. 
-- Они могут быть использованы для выполнения более сложных операций, таких как иерархические запросы или вычисление ранга. 
-- Например:

SELECT e1.name, e1.salary
FROM employees e1
WHERE e1.salary > (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = e1.department_id);

-- 4) Подзапросы во FROM-клаузе: Иногда подзапросы могут быть использованы во FROM-клаузе для обработки 
-- результатов других запросов или создания временных таблиц. 
-- Например:

SELECT department_id, AVG(salary) AS avg_salary
FROM (SELECT department_id, salary FROM employees) AS subquery
GROUP BY department_id;

-- 5) Подзапросы в операторах EXISTS и NOT EXISTS: Эти подзапросы используются для проверки наличия или отсутствия данных, 
-- соответствующих условию, заданному внутри подзапроса. 
-- Например:

SELECT name, department_id
FROM employees
WHERE EXISTS (SELECT 1 FROM departments WHERE id = employees.department_id AND name = 'IT');


